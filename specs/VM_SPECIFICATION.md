# Спецификация виртуальной машины

## Обзор

Виртуальная машина (VM) выполняет байткод, сгенерированный компилятором. VM использует интерпретацию для последовательного выполнения инструкций через switch по opcode.

VM может быть интегрирована с JIT компилятором (см. `JIT_SPECIFICATION.md`) для ускорения выполнения "горячих" функций, но может работать и без него.

## Архитектура виртуальной машины

### Компоненты VM

VM состоит из следующих основных компонентов:

```kotlin
class VirtualMachine(
    private val module: BytecodeModule,
    private val jitCompiler: JITCompilerInterface? = null  // Опциональный JIT
) {
    private val operandStack: RcOperandStack      // Стек операндов
    private val callStack: Stack<CallFrame>       // Стек вызовов функций
    private val memoryManager: MemoryManager       // Управление памятью
}
```

### Структуры данных

#### CallFrame

Фрейм вызова функции содержит всю информацию, необходимую для выполнения функции:

```kotlin
data class CallFrame(
    val function: CompiledFunction,    // Скомпилированная функция
    val locals: RcLocals,              // Локальные переменные + параметры
    var pc: Int,                       // Program Counter (смещение в байтах)
    val returnAddress: Int?            // PC вызывающей функции (для RETURN)
)
```

**Примечания:**
- `pc` указывает на текущую инструкцию в `function.instructions`
- `locals` содержит параметры функции в первых индексах, затем локальные переменные
- `returnAddress` используется для восстановления PC после RETURN

#### VMResult

Коды возврата для обработки ошибок:

```kotlin
enum class VMResult {
    SUCCESS,                    // Успешное выполнение
    DIVISION_BY_ZERO,           // Деление на ноль
    ARRAY_INDEX_OUT_OF_BOUNDS,  // Выход за границы массива
    STACK_UNDERFLOW,            // Недостаточно значений на стеке
    INVALID_OPCODE,             // Неверный opcode
    INVALID_HEAP_ID,            // Неверный heapId
    NEGATIVE_REF_COUNT,         // Отрицательный refCount
    INVALID_FUNCTION_INDEX,     // Неверный индекс функции
    INVALID_CONSTANT_INDEX,     // Неверный индекс константы
    INVALID_LOCAL_INDEX,        // Неверный индекс локальной переменной
    INVALID_ARRAY_TYPE,         // Неверный тип массива
    INVALID_VALUE_TYPE,         // Неверный тип значения
    CALL_STACK_OVERFLOW,        // Переполнение стека вызовов
    OPERAND_STACK_OVERFLOW      // Переполнение стека операндов
}
```

## Цикл интерпретации

### Основной алгоритм

**Инициализация:**
1. Найти функцию точки входа (`entryPoint`) в модуле
2. Создать первый `CallFrame` для этой функции с `pc = 0` и `returnAddress = null`
3. Поместить фрейм в `callStack`

**Основной цикл:**
1. Пока `callStack` не пуст:
   - Получить текущий фрейм из стека
   - Если JIT включен и есть скомпилированная версия функции → выполнить её
   - Иначе интерпретировать одну инструкцию
   - Если результат не `SUCCESS` → вернуть ошибку
2. Вернуть `SUCCESS` при завершении

### Чтение инструкций

Каждая инструкция имеет фиксированный размер 4 байта: `[OPCODE: 1 байт] [OPERAND: 3 байта]`.

**Чтение opcode:**
- Берется байт по адресу `pc`
- Преобразуется в беззнаковое целое (0-255)

**Чтение operand:**
- Читаются 3 байта начиная с `pc + 1` (big-endian)
- Собираются в 24-битное беззнаковое число
- Для инструкций JUMP преобразуется в signed (sign extension, если старший бит установлен)

## Обработка инструкций

### Общий алгоритм

**Проверка конца функции:**
- Если `pc >= instructions.size`, функция завершена
- Удалить фрейм из `callStack`
- Освободить все `ArrayRef` в `locals` (вызвать `clearAndReleaseAll()`)
- Вернуть `SUCCESS`

**Чтение инструкции:**
- Прочитать opcode по адресу `pc`
- Прочитать operand (3 байта) по адресу `pc + 1`

**Выполнение:**
- Использовать switch/when по opcode для выбора обработчика
- Вызвать соответствующий метод выполнения инструкции
- Если результат `SUCCESS` → увеличить `pc` на 4 (следующая инструкция)
- Иначе вернуть код ошибки

**Поддерживаемые инструкции:**
- Константы: `PUSH_INT`, `PUSH_FLOAT`, `PUSH_BOOL`, `POP`
- Локальные переменные: `LOAD_LOCAL`, `STORE_LOCAL`
- Арифметика int: `ADD_INT`, `SUB_INT`, `MUL_INT`, `DIV_INT`, `MOD_INT`, `NEG_INT`
- Арифметика float: `ADD_FLOAT`, `SUB_FLOAT`, `MUL_FLOAT`, `DIV_FLOAT`, `NEG_FLOAT`
- Сравнения int: `EQ_INT`, `NE_INT`, `LT_INT`, `LE_INT`, `GT_INT`, `GE_INT`
- Сравнения float: `EQ_FLOAT`, `NE_FLOAT`, `LT_FLOAT`, `LE_FLOAT`, `GT_FLOAT`, `GE_FLOAT`
- Логические: `AND`, `OR`, `NOT`
- Управление потоком: `JUMP`, `JUMP_IF_FALSE`, `JUMP_IF_TRUE`
- Функции: `CALL`, `RETURN`, `RETURN_VOID`
- Массивы: `NEW_ARRAY_INT`, `NEW_ARRAY_FLOAT`, `NEW_ARRAY_BOOL`, `ARRAY_LOAD`, `ARRAY_STORE`
- Встроенные: `PRINT`, `PRINT_ARRAY`

### Константы

#### PUSH_INT

- **Операнд:** индекс константы в `module.intConstants`
- **Действие:**
  1. Проверить, что индекс валиден
  2. Получить константу из пула
  3. Создать `Value.IntValue` и положить на стек через `pushMove()`
- **Ошибки:** `INVALID_CONSTANT_INDEX` при неверном индексе

#### PUSH_FLOAT

Аналогично `PUSH_INT`, но использует `module.floatConstants` и создает `Value.FloatValue`.

#### PUSH_BOOL

- **Операнд:** `0` (false) или `1` (true)
- **Действие:**
  1. Преобразовать операнд в boolean (`operand != 0`)
  2. Создать `Value.BoolValue` и положить на стек через `pushMove()`

#### POP

- **Операнд:** игнорируется
- **Действие:**
  1. Удалить верхний элемент стека через `popDrop()` (выполняет `release` для `ArrayRef`)

### Локальные переменные

#### LOAD_LOCAL

- **Операнд:** индекс локальной переменной
- **Действие:**
  1. Проверить валидность индекса
  2. Получить значение из `locals` через `getCopy()` (выполняет `retain` для `ArrayRef`)
  3. Положить значение на стек через `pushCopy()`
- **RC правило:** COPY семантика → `retain` выполняется автоматически
- **Ошибки:** `INVALID_LOCAL_INDEX` при неверном индексе

#### STORE_LOCAL

- **Операнд:** индекс локальной переменной
- **Действие:**
  1. Проверить валидность индекса
  2. Снять значение со стека через `popMove()` (MOVE семантика)
  3. Записать в `locals` через `setMove()` (выполняет `release` старого значения)
- **RC правило:** MOVE семантика → `release` старого значения выполняется автоматически
- **Ошибки:** `INVALID_LOCAL_INDEX`, `STACK_UNDERFLOW`

### Арифметические операции

#### ADD_INT

- **Операнд:** игнорируется
- **Действие:**
  1. Проверить, что на стеке минимум 2 значения
  2. Снять два верхних значения (`b`, затем `a`)
  3. Проверить, что оба являются `Value.IntValue`
  4. Выполнить сложение `a + b`
  5. Положить результат на стек как `Value.IntValue`
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`

Аналогично для `SUB_INT` (вычитание), `MUL_INT` (умножение), `DIV_INT` (деление), `MOD_INT` (остаток), `NEG_INT` (унарный минус, один операнд).

**Специальные ошибки:**
- `DIV_INT` и `MOD_INT`: `DIVISION_BY_ZERO` при делении на ноль

#### Арифметика float

Аналогично int операциям, но:
- Использует `Value.FloatValue`
- Операции выполняются с типом `Double`
- `NEG_FLOAT` - унарный минус для float

### Операции сравнения

#### EQ_INT

- **Операнд:** игнорируется
- **Действие:**
  1. Снять два верхних значения со стека
  2. Проверить, что оба являются `Value.IntValue`
  3. Сравнить на равенство (`a == b`)
  4. Положить результат как `Value.BoolValue` на стек
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`

Аналогично для:
- `NE_INT` - неравенство (`a != b`)
- `LT_INT` - меньше (`a < b`)
- `LE_INT` - меньше или равно (`a <= b`)
- `GT_INT` - больше (`a > b`)
- `GE_INT` - больше или равно (`a >= b`)

#### Сравнения float

Аналогично int сравнениям, но использует `Value.FloatValue` и операции с `Double`.

### Логические операции

#### AND

- **Операнд:** игнорируется
- **Действие:**
  1. Снять два верхних значения со стека
  2. Проверить, что оба являются `Value.BoolValue`
  3. Выполнить логическое И (`a && b`)
  4. Положить результат как `Value.BoolValue` на стек
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`

#### OR

Аналогично `AND`, но выполняет логическое ИЛИ (`a || b`).

#### NOT

- **Операнд:** игнорируется
- **Действие:**
  1. Снять одно значение со стека
  2. Проверить, что является `Value.BoolValue`
  3. Выполнить логическое НЕ (`!value`)
  4. Положить результат на стек

### Управление потоком

#### JUMP

- **Операнд:** смещение в инструкциях (signed, может быть отрицательным)
- **Действие:**
  1. Вычислить новое значение PC: `newPC = currentPC + (operand * 4) + 4`
     - `+4` чтобы пропустить текущую инструкцию
     - `operand * 4` потому что смещение в инструкциях, а не байтах
  2. Проверить, что `newPC` в пределах функции
  3. Установить `frame.pc = newPC - 4` (компенсация за автоматическое увеличение в цикле)
- **Ошибки:** `INVALID_OPCODE` при выходе за границы

#### JUMP_IF_FALSE

- **Операнд:** смещение в инструкциях (signed)
- **Действие:**
  1. Снять верхнее значение со стека
  2. Проверить, что является `Value.BoolValue`
  3. Если значение `false`:
     - Вычислить новое PC аналогично `JUMP`
     - Установить `frame.pc`
  4. Если значение `true` → продолжить выполнение со следующей инструкции
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`

#### JUMP_IF_TRUE

Аналогично `JUMP_IF_FALSE`, но переходит, если значение `true`.

### Функции

#### CALL

- **Операнд:** индекс функции в `module.functions`
- **Действие:**
  1. Проверить валидность индекса функции
  2. Получить функцию из модуля
  3. Если JIT включен → вызвать `jitCompiler.recordCall(function.name)` для профилирования
  4. Снять аргументы со стека в обратном порядке (последний параметр первым)
  5. Создать новый `CallFrame`:
     - `function` = вызываемая функция
     - `locals` = новый `RcLocals` с размером `function.localsCount`
     - `pc` = 0 (начало функции)
     - `returnAddress` = `callerFrame.pc + 4` (инструкция после CALL)
  6. Инициализировать параметры в `locals` (первые индексы) через `setMove()` (MOVE семантика)
  7. Поместить новый фрейм в `callStack`
  8. Если JIT включен и есть скомпилированная версия → переключиться на неё
- **Ошибки:** `INVALID_FUNCTION_INDEX`, `STACK_UNDERFLOW`
- **RC правило:** Аргументы передаются через MOVE (retain не нужен)

#### RETURN

- **Операнд:** игнорируется
- **Действие:**
  1. Проверить, что на стеке есть возвращаемое значение
  2. Снять значение со стека
  3. Освободить все `ArrayRef` в `locals` через `clearAndReleaseAll()`
  4. Удалить текущий фрейм из `callStack`
  5. Если есть вызывающий фрейм:
     - Положить возвращаемое значение на стек вызывающего через `pushMove()` (MOVE семантика)
     - Восстановить PC вызывающего: `callerFrame.pc = returnAddress`
- **Ошибки:** `STACK_UNDERFLOW`
- **RC правило:** Возвращаемое значение передается через MOVE (retain не нужен)

#### RETURN_VOID

- **Операнд:** игнорируется
- **Действие:**
  1. Освободить все `ArrayRef` в `locals`
  2. Удалить текущий фрейм из `callStack`
  3. Если есть вызывающий фрейм → восстановить его PC

### Массивы

#### NEW_ARRAY_INT

- **Операнд:** игнорируется
- **Действие:**
  1. Снять размер массива со стека (должен быть `Value.IntValue`)
  2. Проверить, что размер >= 0
  3. Вызвать `memoryManager.newIntArray(size)` (создает массив с `refCount = 1`)
  4. Положить `Value.ArrayRef` на стек через `pushMove()`
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`, `ARRAY_INDEX_OUT_OF_BOUNDS` (при отрицательном размере)

Аналогично для `NEW_ARRAY_FLOAT` и `NEW_ARRAY_BOOL`.

#### ARRAY_LOAD

- **Операнд:** игнорируется
- **Действие:**
  1. Снять индекс со стека (должен быть `Value.IntValue`)
  2. Снять ссылку на массив со стека (должен быть `Value.ArrayRef`)
  3. Определить тип массива (int[], float[], bool[])
  4. Вызвать соответствующий метод `memoryManager.*ArrayLoad(ref, index)`
  5. Положить значение на стек как соответствующий `Value`
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`, `ARRAY_INDEX_OUT_OF_BOUNDS`, `INVALID_HEAP_ID`

**Примечание:** В реальной реализации необходимо определять тип массива для вызова соответствующего метода `memoryManager`. Это можно сделать через проверку типа объекта в куче или через дополнительную информацию в байткоде.

#### ARRAY_STORE

- **Операнд:** игнорируется
- **Действие:**
  1. Снять значение со стека
  2. Снять индекс со стека (должен быть `Value.IntValue`)
  3. Снять ссылку на массив со стека (должен быть `Value.ArrayRef`)
  4. Определить тип значения и вызвать соответствующий метод:
     - `Value.IntValue` → `memoryManager.intArrayStore(ref, index, value)`
     - `Value.FloatValue` → `memoryManager.floatArrayStore(ref, index, value)`
     - `Value.BoolValue` → `memoryManager.boolArrayStore(ref, index, value)`
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`, `ARRAY_INDEX_OUT_OF_BOUNDS`, `INVALID_HEAP_ID`

### Встроенные функции

#### PRINT

- **Операнд:** игнорируется
- **Действие:**
  1. Снять значение со стека
  2. В зависимости от типа значения:
     - `Value.IntValue` → вывести целое число
     - `Value.FloatValue` → вывести число с плавающей точкой
     - `Value.BoolValue` → вывести "true" или "false"
  3. Вывод в стандартный поток вывода
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE` (для неподдерживаемых типов)

#### PRINT_ARRAY

- **Операнд:** игнорируется
- **Действие:**
  1. Снять ссылку на массив со стека (должен быть `Value.ArrayRef`)
  2. Извлечь массив из кучи по `heapId`
  3. Определить тип массива (int[], float[], bool[])
  4. Вывести массив в формате `[element1, element2, ...]` с разделителями ", "
- **Ошибки:** `STACK_UNDERFLOW`, `INVALID_VALUE_TYPE`, `INVALID_ARRAY_TYPE`, `INVALID_HEAP_ID`

## Управление памятью (Reference Counting)

### Правила retain/release

VM использует готовые классы `RcOperandStack` и `RcLocals` для управления памятью:

| Операция | Семантика | RC действие |
|----------|-----------|-------------|
| LOAD_LOCAL | COPY из locals в стек | `retain` перед push |
| STORE_LOCAL | MOVE из стека в locals | `release` старого значения |
| POP | DROP значение | `release` |
| CALL | MOVE аргументов | Без retain (move) |
| RETURN | MOVE возвращаемого значения | Без retain (move) |
| Завершение фрейма | Очистка locals | `release` всех ArrayRef |

### Завершение функции

При завершении функции (RETURN или достижение конца) необходимо:
- Вызвать `frame.locals.clearAndReleaseAll()` для освобождения всех `ArrayRef` в локальных переменных
- Это гарантирует, что объекты в куче будут корректно освобождены при выходе из функции

## Интеграция с JIT компилятором

VM может работать с JIT компилятором через интерфейс `JITCompilerInterface`:

```kotlin
interface JITCompilerInterface {
    fun recordCall(functionName: String)
    fun getCompiled(functionName: String): CompiledFunctionExecutor?
    fun isEnabled(): Boolean
}
```

VM вызывает методы интерфейса в двух точках:
1. При вызове функции (CALL) - для профилирования
2. В начале интерпретации - для проверки наличия скомпилированной версии

Подробности см. в `JIT_SPECIFICATION.md`.

## Обработка ошибок

VM не выполняет проверки типов во время выполнения (полагается на семантический анализ). Все ошибки возвращают соответствующий `VMResult`:

- **Деление на ноль** → `VMResult.DIVISION_BY_ZERO`
- **Выход за границы массива** → `VMResult.ARRAY_INDEX_OUT_OF_BOUNDS`
- **Недостаточно значений на стеке** → `VMResult.STACK_UNDERFLOW`
- **Неверный opcode** → `VMResult.INVALID_OPCODE`
- **Неверный heapId** → `VMResult.INVALID_HEAP_ID`

## Производительность

### Интерпретация

- **Overhead на каждую инструкцию:** ~40-80 нс (switch + чтение байткода)
- **Подходит для:** однократного выполнения, отладки, простых программ
- **Преимущества:** простая реализация, предсказуемое поведение
- **Недостатки:** медленнее для циклов и часто вызываемых функций

### Оптимизации интерпретации

Для улучшения производительности интерпретации можно:
- Использовать таблицу переходов вместо switch
- Кэшировать часто используемые значения
- Оптимизировать чтение инструкций

Однако для значительного ускорения рекомендуется использовать JIT компиляцию (см. `JIT_SPECIFICATION.md`).

## Резюме

VM выполняет байткод через интерпретацию. Интерпретация проста в реализации и подходит для отладки и простых программ. Для ускорения выполнения "горячих" функций VM может быть интегрирована с JIT компилятором.

