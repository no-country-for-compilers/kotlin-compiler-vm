# Спецификация JIT компилятора

## Обзор

JIT (Just-In-Time) компилятор динамически оптимизирует байткод "горячих" функций для ускорения выполнения. Работает совместно с виртуальной машиной, автоматически определяя функции, которые вызываются часто, и заменяя их байткод на оптимизированные версии.

## Архитектура

### Компоненты

```kotlin
class BytecodeOptimizerJIT(
    private val module: BytecodeModule,
    private val threshold: Int = 1000,
    maxParallelOptimizations: Int = min(availableProcessors, 4)
) : JITCompilerInterface, AutoCloseable {
    private val callCounts: ConcurrentHashMap<String, AtomicInteger>
    private val optimizedFunctions: ConcurrentHashMap<String, CompiledFunction>
    private val inProgress: ConcurrentHashMap<String, CompletableDeferred<CompiledFunction?>>
    private val optimizedModuleFunctions: ConcurrentHashMap<Int, CompiledFunction>
    private val executorService: ExecutorService
    private val semaphore: Semaphore
    private val scope: CoroutineScope
}
```

### Интерфейс

```kotlin
interface JITCompilerInterface {
    fun recordCall(functionName: String)
    fun getCompiled(functionName: String): CompiledFunctionExecutor?
    fun isEnabled(): Boolean
}
```

## Профилирование

### Механизм

1. При каждом вызове функции VM вызывает `recordCall(functionName)`
2. Увеличивается счётчик вызовов (thread-safe через `AtomicInteger`)
3. Если функция уже оптимизирована, профилирование пропускается (fast path)
4. Если счётчик достиг порога (`threshold`) и функция ещё не оптимизирована:
   - Запускается асинхронная оптимизация функции в фоновом потоке

**Порог оптимизации:** По умолчанию 1000 вызовов.

## Оптимизация

### Асинхронная оптимизация

Оптимизация выполняется асинхронно через Kotlin Coroutines, чтобы не блокировать выполнение программы.

**Алгоритм:**
1. Проверка, что функция ещё не оптимизирована (double-check)
2. Проверка, что оптимизация не выполняется уже (через `inProgress`)
3. Создание `CompletableDeferred` для отслеживания результата
4. Запуск корутины в `scope` с диспетчером из пула потоков
5. Получение семафора для ограничения параллельных оптимизаций (timeout 5 секунд)
6. Вызов `BytecodeOptimizer.optimizeFunction()`
7. Сохранение результата в `optimizedFunctions` и `optimizedModuleFunctions`
8. Освобождение семафора и удаление из `inProgress`

### Ограничение параллелизма

- Используется `Semaphore` для ограничения количества одновременных оптимизаций
- По умолчанию: `min(availableProcessors, 4)`
- Если семафор недоступен в течение 5 секунд, оптимизация отменяется

### Защита от двойной оптимизации

Используется комбинация механизмов:
1. Проверка `optimizedFunctions.containsKey()` перед запуском
2. Double-check после инкремента счётчика
3. `ConcurrentHashMap.putIfAbsent()` для атомарной вставки в `inProgress`
4. `CompletableDeferred` для отслеживания состояния оптимизации

## Bytecode Optimizer

### Обзор

Оптимизатор заменяет паттерны инструкций на более эффективные эквиваленты, уменьшая количество инструкций и упрощая выполнение.

**Процесс оптимизации:**
1. Поиск оптимизируемых паттернов в байткоде
2. Построение карты адресов (original -> new)
3. Пересчёт адресов переходов
4. Генерация оптимизированного байткода

### Оптимизируемые паттерны

#### Паттерн 1: Инкремент локальной переменной

**Заменяет:**
```
LOAD_LOCAL #X
PUSH_INT #constIndex  (где constIndex указывает на константу 1)
ADD_INT
STORE_LOCAL #X
```

**На:**
```
INC_LOCAL #X
```

**Условия:**
- `constIndex` должен указывать на константу со значением 1
- Если модуль не предоставлен, предполагается, что индекс 0 = константа 1

#### Паттерн 2: Декремент локальной переменной

**Заменяет:**
```
LOAD_LOCAL #X
PUSH_INT #constIndex  (где constIndex указывает на константу 1)
SUB_INT
STORE_LOCAL #X
```

**На:**
```
DEC_LOCAL #X
```

**Условия:**
- Аналогично паттерну 1

### Алгоритм оптимизации

Оптимизация выполняется в три прохода:

**Первый проход:** поиск оптимизаций
- Проход по всем инструкциям (по адресам, кратных 4 байтам)
- Для каждой инструкции проверка соответствия паттернам
- Сохранение найденных оптимизаций: `(originalAddress -> (newOpcode, newOperand, skipCount))`

**Второй проход:** построение карты адресов
- Создание отображения `originalAddress -> newAddress`
- Учёт того, что оптимизированные паттерны занимают меньше инструкций

**Третий проход:** генерация оптимизированного байткода
- Проход по оригинальным инструкциям
- Для оптимизированных паттернов: генерация новой инструкции
- Для инструкций переходов: пересчёт относительных адресов
- Для остальных: копирование без изменений

### Пересчёт адресов переходов

После оптимизации размер байткода может измениться, поэтому необходимо пересчитать адреса для инструкций:
- `JUMP`
- `JUMP_IF_FALSE`
- `JUMP_IF_TRUE`

**Алгоритм пересчёта:**
1. Преобразование operand в signed (sign extension для отрицательных значений)
2. Вычисление целевого адреса: `targetOriginalAddress = originalAddress + signedOperand`
3. Получение нового адреса цели из карты: `targetNewAddress = addressMap[targetOriginalAddress]`
4. Вычисление нового operand: `newOperand = targetNewAddress - addressMap[originalAddress]`

## Интеграция с VM

### Профилирование

VM вызывает `recordCall()` при каждом вызове функции:

```kotlin
if (jitCompiler?.isEnabled() == true) {
    jitCompiler.recordCall(function.name)
}
```

### Использование оптимизированного байткода

VM проверяет наличие оптимизированной версии при вызове функции (CALL):

```kotlin
val optimizedFunction = if (jitCompiler is BytecodeOptimizerJIT) {
    jitCompiler.getOptimizedFunction(operand)
} else {
    null
}
```

**Выбор функции:**
1. Если оптимизированная версия доступна, проверяется соответствие сигнатуры:
   - Количество параметров
   - Количество локальных переменных
   - Тип возвращаемого значения
2. Если сигнатура совпадает, используется оптимизированная версия
3. Иначе используется оригинальная функция

**Создание CallFrame:**
- `CallFrame` создаётся с оптимизированной функцией (если доступна)
- Выполнение происходит через обычную интерпретацию
- Оптимизированный байткод выполняется так же, как оригинальный

## Управление ресурсами

### Завершение работы

JIT компилятор реализует `AutoCloseable`:

```kotlin
fun shutdown() {
    scope.cancel()  // Отмена всех корутин
    executorService.shutdown()
    executorService.awaitTermination(1, TimeUnit.SECONDS)
}
```

### Включение/выключение

JIT может быть временно отключён:

```kotlin
fun setEnabled(value: Boolean)
override fun isEnabled(): Boolean
```

## Производительность

### Overhead оптимизации

- Время оптимизации: ~0.1-1 мс на функцию (один раз)
- Память: минимальная (только хранение оптимизированного байткода)
- Overhead профилирования: минимальный (атомарный инкремент)

### Ускорение выполнения

После оптимизации функции выполняются быстрее за счёт:
- Меньшего количества инструкций (4 инструкции → 1)
- Меньшего количества операций со стеком
- Более эффективного использования локальных переменных

**Ожидаемое ускорение:**
- Функции с циклами, содержащими инкременты/декременты: 1.2-2x
- Общее ускорение зависит от доли оптимизируемых паттернов в коде

### Источники ускорения

1. Уменьшение количества инструкций
2. Уменьшение операций со стеком операндов
3. Более эффективное использование локальных переменных

## Обработка ошибок

- Ошибки оптимизации логируются в stderr, функция продолжает выполняться с оригинальным байткодом
- Ошибки выполнения обрабатываются так же, как в обычной интерпретации
- Если оптимизация не удалась, возвращается `null`, и используется оригинальная функция
- Отмена оптимизации (timeout семафора) обрабатывается через `CancellationException`

## Пример использования

```kotlin
// Создание JIT компилятора
val jit = BytecodeOptimizerJIT(
    module = module,
    threshold = 10,  // Оптимизировать после 10 вызовов
    maxParallelOptimizations = 2
)

// Создание VM с JIT
val vm = VirtualMachine(module, jit)

// Выполнение - JIT автоматически оптимизирует "горячие" функции
val result = vm.execute()

// Закрытие ресурсов
jit.close()
```
